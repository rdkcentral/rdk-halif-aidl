# RDK Hardware Abstraction Layer and Binder

The 2023 RDK HAL study identified key design goals for a new HAL interface and implementation, focusing on the following aspects:

## Design Goals

- **Clean Separation:** Clear division between middleware and vendor layers.
- **Process Isolation:** Middleware and vendor layers operate in separate processes and memory spaces.
- **Late Binding:** Decoupling of middleware from vendor HAL components at build time.
- **Versioning:** Versioned interfaces with forward and backward compatibility.
- **Performance:** High-performance Inter-Process Communication (IPC).
- **Testability:** Standalone testability for the vendor layer.
- **Debuggability:** Enhanced debugging tools.

## Binder

Binder is the chosen Inter-Process Communication (IPC) mechanism for RDK HALs. It offers both synchronous and asynchronous calls, crucial for the diverse communication needs of subsystems like A/V.  Implementing HAL interfaces as Binder services provides:

- **Process and Memory Isolation:** Enhances stability, testability, and memory management.  HAL crashes are isolated and won't bring down the entire system.  This also improves security.
- **Late Binding:** Eliminates build-time dependencies on vendor HAL libraries, enabling independent delivery and updates of middleware and vendor layers.  This simplifies the build process and allows for more flexible deployments.

Binder is implemented as a Linux kernel driver that must be enabled during kernel compilation.

## AIDL

AIDL (Android Interface Definition Language) is used to define the interfaces for Binder services.  It acts as a contract between the client (e.g., middleware) and the server (e.g., HAL implementation). RDK leverages C++ bindings generated by the AIDL tool to create client-side proxy and server-side stub implementations. All Binder-based HAL interfaces are defined in AIDL files, typically located in a dedicated repository (e.g., `rdk-halif-aidl`).

Stable AIDL is crucial for maintaining compatibility across interface versions. It enables runtime version detection, allowing clients to verify the HAL service version they are communicating with. This ensures interoperability even when client and server components are built against different interface versions.

## Why use AIDL with Binder for HALs?

AIDL provides a structured and standardized way to define the interfaces between the framework (or in this case, the RDK middleware) and the hardware-specific HAL implementation.  This is critical for several reasons:

- **Standardized Interface Definition:** AIDL provides a clear, concise, and language-agnostic way to define the functions, parameters, and return values of the HAL interface. This ensures both the middleware and the HAL understand the contract, preventing ambiguity and errors.

- **Binder Integration:**  AIDL is tightly integrated with Binder.  The AIDL compiler generates the code necessary for marshaling (packaging) and unmarshaling (unpacking) data as it's passed between processes via Binder. This significantly simplifies the development process.

- **Code Generation:** The AIDL compiler automates the creation of boilerplate code (proxies and stubs) required for Binder communication.  This saves developers significant time and effort, allowing them to focus on the core logic of the HAL implementation.

- **Versioning and Compatibility:** Stable AIDL allows for evolving the HAL interface over time while maintaining backward compatibility.  This is essential for ensuring that updates to the HAL or middleware don't break existing components.

- **Abstraction:** AIDL abstracts away the complexities of inter-process communication.  Developers don't need to worry about the underlying Binder mechanisms; the generated code handles this automatically.

## Key Concepts and Benefits

- **Interface Definition:** AIDL provides a structured, language-agnostic way to define the contract between the client and server.
- **Code Generation:** The AIDL compiler generates the necessary code for Binder communication.
- **Proxy/Stub:** Client-side proxies handle communication with the server, while server-side stubs receive and process requests.
- **Versioning:** Stable AIDL allows for interface evolution while preserving backward compatibility.
- **Process Isolation:** Binder services run in separate processes, improving system stability.
- **Late Binding:** Reduces dependencies and simplifies updates.

## Useful External Links

- **RDK HAL AIDL Git Repository:** [RDK HAL AIDL](https://github.com/rdkcentral/rdk-halif-aidl)
- **Kernel Binder Driver:** [Kernel Binder](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/android?h=v5.15.164)

## AIDL Documentation

- [AIDL Overview](https://developer.android.com/develop/background-work/services/aidl)
- [AIDL Core Architecture](https://source.android.com/docs/core/architecture/aidl)
- [AIDL Language](https://source.android.com/docs/core/architecture/aidl/aidl-language)
- [AIDL HALs](https://source.android.com/docs/core/architecture/aidl/aidl-hals)
- [Stable AIDL](https://source.android.com/docs/core/architecture/aidl/stable-aidl)

## Binder Tracing Tools

- [Binder Trace](https://github.com/foundryzero/binder-trace)
- [Binder Tracing Part 2](https://www.foundryzero.co.uk/2022/11/14/binder-tracing-part-2.html)
- [Eclipse Trace Compass](https://eclipse.dev/tracecompass/)
- [Android Performance Tracing](https://developer.android.com/topic/performance/tracing)
- [Binder Explorer](https://github.com/opersys/binder-explorer-web)

